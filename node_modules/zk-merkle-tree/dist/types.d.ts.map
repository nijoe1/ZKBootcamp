{"mappings":";AA6CA,oBAA2B,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;ACjC/C,uCAEC;AAMD;;;;;GAYC;AAED,8BAA8B,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,MAAM,SAMtD;AAGD,2CAA2C,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,GAAG,EAAE,EAAE,OAAO,CAAC,EAAE,GAAG;;;;EAuCnG;AAED,iCAAiC,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,MAAM,EAAE,YAAY,EAAE,GAAG,EAAE,EAAE,WAAW,EAAE,GAAG,EAAE,EAAE,OAAO,EAAE,GAAG,OAgBhH;AAED,qDAA2D,IAAI,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG,EAAE,QAAQ,EAAE,GAAG,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG;;;;GAW9H;AAED,gCAAgC,QAAQ,KAAA;;;;;EAkBvC;AAED,8CAAoD,OAAO,EAAE,GAAG,EAAE,QAAQ,EAAE,GAAG,EAAE,MAAM,EAAE,MAAM,EAAE,UAAU,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG;;;;;;GAkB1H","sources":["src/typechain-types/common.ts","src/src/zktree.ts","src/zktree.ts"],"sourcesContent":[null,null,"// based on https://github.com/tornadocash/fixed-merkle-tree\n\nimport * as crypto from 'crypto'\nimport * as snarkjs from 'snarkjs'\nimport { buildMimcSponge } from 'circomlibjs'\nimport { PromiseOrValue } from \"../typechain-types/common\";\nimport { BigNumberish, BigNumber, Contract } from \"ethers\";\n\nconst ZERO_VALUE = BigNumber.from('21663839004416932945382355908790599225266501822907911457504978515578255421292') // = keccak256(\"tornado\") % FIELD_SIZE\n\nimport loadWebAssembly from './Verifier'\n\nexport function getVerifierWASM() {\n    return loadWebAssembly().buffer\n}\n\nfunction calculateHash(mimc, left, right) {\n    return BigNumber.from(mimc.F.toString(mimc.multiHash([left, right])))\n}\n\nexport async function generateCommitment() {\n    const mimc = await buildMimcSponge();\n    const nullifier = BigNumber.from(crypto.randomBytes(31)).toString()\n    const secret = BigNumber.from(crypto.randomBytes(31)).toString()\n    const commitment = mimc.F.toString(mimc.multiHash([nullifier, secret]))\n    const nullifierHash = mimc.F.toString(mimc.multiHash([nullifier]))\n    return {\n        nullifier: nullifier,\n        secret: secret,\n        commitment: commitment,\n        nullifierHash: nullifierHash\n    }\n}\n\nexport function generateZeros(mimc: any, levels: number) {\n    let zeros = []\n    zeros[0] = ZERO_VALUE\n    for (let i = 1; i <= levels; i++)\n        zeros[i] = calculateHash(mimc, zeros[i - 1], zeros[i - 1]);\n    return zeros\n}\n\n// calculates Merkle root from elements and a path to the given element \nexport function calculateMerkleRootAndPath(mimc: any, levels: number, elements: any[], element?: any) {\n    const capacity = 2 ** levels\n    if (elements.length > capacity) throw new Error('Tree is full')\n\n    const zeros = generateZeros(mimc, levels);\n    let layers = []\n    layers[0] = elements.slice()\n    for (let level = 1; level <= levels; level++) {\n        layers[level] = []\n        for (let i = 0; i < Math.ceil(layers[level - 1].length / 2); i++) {\n            layers[level][i] = calculateHash(\n                mimc,\n                layers[level - 1][i * 2],\n                i * 2 + 1 < layers[level - 1].length ? layers[level - 1][i * 2 + 1] : zeros[level - 1],\n            )\n        }\n    }\n\n    const root = layers[levels].length > 0 ? layers[levels][0] : zeros[levels - 1]\n\n    let pathElements = []\n    let pathIndices = []\n\n    if (element) {\n        const bne = BigNumber.from(element)\n        let index = layers[0].findIndex(e => BigNumber.from(e).eq(bne))\n        // console.log('idx: ' + index)\n        for (let level = 0; level < levels; level++) {\n            pathIndices[level] = index % 2\n            pathElements[level] = (index ^ 1) < layers[level].length ? layers[level][index ^ 1] : zeros[level]\n            index >>= 1\n        }\n    }\n\n    return {\n        root: root.toString(),\n        pathElements: pathElements.map((v) => v.toString()),\n        pathIndices: pathIndices.map((v) => v.toString())\n    }\n}\n\nexport function checkMerkleProof(mimc: any, levels: number, pathElements: any[], pathIndices: any[], element: any) {\n    // console.log(pathElements)\n    // console.log(pathIndices)\n    let hashes = []\n    for (let i = 0; i < levels; i++) {\n        const in0 = (i == 0) ? element : hashes[i - 1]\n        const in1 = pathElements[i]\n        // console.log(`in0: ${in0} in1: ${in1}`)\n        if (pathIndices[i] == 0) {\n            hashes[i] = calculateHash(mimc, in0, in1)\n        } else {\n            hashes[i] = calculateHash(mimc, in1, in0)\n        }\n        // console.log(`in0: ${in0} in1: ${in1} hash: ${hashes[i]}`)\n    }\n    return hashes[levels - 1]\n}\n\nexport async function calculateMerkleRootAndPathFromEvents(mimc: any, address: any, provider: any, levels: number, element: any) {\n    const abi = [\n        \"event Commit(bytes32 indexed commitment,uint32 leafIndex,uint256 timestamp)\"\n    ];\n    const contract = new Contract(address, abi, provider)\n    const events = await contract.queryFilter(contract.filters.Commit())\n    let commitments = []\n    for (let event of events) {\n        commitments.push(BigNumber.from(event.args.commitment))\n    }\n    return calculateMerkleRootAndPath(mimc, levels, commitments, element)\n}\n\nexport function convertCallData(calldata) {\n    const argv = calldata\n        .replace(/[\"[\\]\\s]/g, \"\")\n        .split(\",\")\n        .map((x) => BigNumber.from(x).toString());\n\n    const a = [argv[0], argv[1]] as [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>];\n    const b = [\n        [argv[2], argv[3]],\n        [argv[4], argv[5]],\n    ] as [\n            [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],\n            [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]\n        ];\n    const c = [argv[6], argv[7]] as [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>];\n    const input = [argv[8], argv[9]] as [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>];\n\n    return { a, b, c, input };\n}\n\nexport async function calculateMerkleRootAndZKProof(address: any, provider: any, levels: number, commitment: any, zkey: any) {\n    const mimc = await buildMimcSponge();\n    const rootAndPath = await calculateMerkleRootAndPathFromEvents(mimc, address, provider, levels, commitment.commitment);\n    const { proof, publicSignals } = await snarkjs.groth16.fullProve(\n        {\n            nullifier: commitment.nullifier, secret: commitment.secret,\n            pathElements: rootAndPath.pathElements, pathIndices: rootAndPath.pathIndices\n        },\n        getVerifierWASM(),\n        zkey);\n    const cd = convertCallData(await snarkjs.groth16.exportSolidityCallData(proof, publicSignals));\n    return {\n        nullifierHash: publicSignals[0],\n        root: publicSignals[1],\n        proof_a: cd.a,\n        proof_b: cd.b,\n        proof_c: cd.c\n    }\n}"],"names":[],"version":3,"file":"types.d.ts.map"}